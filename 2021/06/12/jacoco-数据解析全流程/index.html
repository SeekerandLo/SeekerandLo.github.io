<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>jacoco: 数据解析全流程 | aoldu.com</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="最近在做代码覆盖率相关工作开发，本文对 java 的覆盖率工具 jacoco 解析 exec 数据的流程做一个简单介绍，是通过阅读源码和 debug 的方式来学习。本文将通过 javaagent 的形式使用 jacoco。">
<meta property="og:type" content="article">
<meta property="og:title" content="jacoco: 数据解析全流程">
<meta property="og:url" content="http://example.com/2021/06/12/jacoco-%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%90%E5%85%A8%E6%B5%81%E7%A8%8B/index.html">
<meta property="og:site_name" content="aoldu.com">
<meta property="og:description" content="最近在做代码覆盖率相关工作开发，本文对 java 的覆盖率工具 jacoco 解析 exec 数据的流程做一个简单介绍，是通过阅读源码和 debug 的方式来学习。本文将通过 javaagent 的形式使用 jacoco。">
<meta property="og:locale">
<meta property="og:image" content="http://example.com/2021/06/12/jacoco-%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%90%E5%85%A8%E6%B5%81%E7%A8%8B/resources.PNG">
<meta property="og:image" content="http://example.com/2021/06/12/jacoco-%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%90%E5%85%A8%E6%B5%81%E7%A8%8B/exec-load.PNG">
<meta property="og:image" content="http://example.com/2021/06/12/jacoco-%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%90%E5%85%A8%E6%B5%81%E7%A8%8B/executionDataStore.PNG">
<meta property="og:image" content="http://example.com/2021/06/12/jacoco-%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%90%E5%85%A8%E6%B5%81%E7%A8%8B/ClassVisitor.PNG">
<meta property="og:image" content="http://example.com/2021/06/12/jacoco-%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%90%E5%85%A8%E6%B5%81%E7%A8%8B/methodsCount.PNG">
<meta property="og:image" content="http://example.com/2021/06/12/jacoco-%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%90%E5%85%A8%E6%B5%81%E7%A8%8B/AbstractInsnNode.PNG">
<meta property="og:image" content="http://example.com/2021/06/12/jacoco-%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%90%E5%85%A8%E6%B5%81%E7%A8%8B/name-desc-signature.PNG">
<meta property="og:image" content="http://example.com/2021/06/12/jacoco-%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%90%E5%85%A8%E6%B5%81%E7%A8%8B/calculate.PNG">
<meta property="og:image" content="http://example.com/2021/06/12/jacoco-%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%90%E5%85%A8%E6%B5%81%E7%A8%8B/incrementMethodCounter.PNG">
<meta property="og:image" content="http://example.com/2021/06/12/jacoco-%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%90%E5%85%A8%E6%B5%81%E7%A8%8B/coverage-addMethod.PNG">
<meta property="article:published_time" content="2021-06-12T11:57:32.000Z">
<meta property="article:modified_time" content="2021-06-14T10:34:36.369Z">
<meta property="article:author" content="Liy">
<meta property="article:tag" content="jacoco">
<meta property="article:tag" content="覆盖率">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2021/06/12/jacoco-%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%90%E5%85%A8%E6%B5%81%E7%A8%8B/resources.PNG">
  
    <link rel="alternate" href="/atom.xml" title="aoldu.com" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">aoldu.com</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Suche"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Suche"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-jacoco-数据解析全流程" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/12/jacoco-%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%90%E5%85%A8%E6%B5%81%E7%A8%8B/" class="article-date">
  <time class="dt-published" datetime="2021-06-12T11:57:32.000Z" itemprop="datePublished">2021-06-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%A6%86%E7%9B%96%E7%8E%87/">服务端覆盖率</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      jacoco: 数据解析全流程
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>最近在做代码覆盖率相关工作开发，本文对 java 的覆盖率工具 jacoco 解析 exec 数据的流程做一个简单介绍，是通过阅读源码和 debug 的方式来学习。本文将通过 javaagent 的形式使用 jacoco。</p>
<span id="more"></span>

<h2 id="jacoco"><a href="#jacoco" class="headerlink" title="jacoco"></a>jacoco</h2><blockquote>
<p>JaCoCo is a free code coverage library for Java, which has been created by the EclEmma team based on the lessons learned from using and integration existing libraries for many years.</p>
</blockquote>
<p>相关资料指路：</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://www.eclemma.org/jacoco/index.html">jacoco 官网</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/SeekerandLo/blog-projects/tree/main/jacoco-demo">本文使用的测试项目</a></li>
</ol>
<h2 id="项目准备"><a href="#项目准备" class="headerlink" title="项目准备"></a>项目准备</h2><p>通过 javaagent 方式使用 jacoco，首先需要转变 javaagent.jar、一个被测试项目、一个使用 jacoco api 生成覆盖率报告的项目。被测试项目这里使用一个简单的 spring boot 服务，提供一个 Controller 和一个 Service。</p>
<h3 id="aserver：被测试项目"><a href="#aserver：被测试项目" class="headerlink" title="aserver：被测试项目"></a>aserver：被测试项目</h3><p>配置被测试项目的 JVM 参数，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-javaagent=jacocoagent.jar,includes=com.*.*,classdumpdir=[某路径],output=tcpserver,address=127.0.0.1,port=6300</span><br></pre></td></tr></table></figure>
<p>配置完成后，启动被测试项目。之后就可以拉取到 exec 文件了。<br>被测试项目部分代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// controller</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;aserver/&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AController</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  AService aService;</span><br><span class="line">  <span class="meta">@GetMapping(&quot;add.json&quot;)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> ResponseEntity&lt;Integer&gt; <span class="title">add</span><span class="params">(<span class="meta">@RequestParam</span> Integer p1, <span class="meta">@RequestParam</span> Integer p2)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ResponseEntity.ok(aService.add(p1, p2));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@GetMapping(&quot;if-test.json&quot;)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> ResponseEntity&lt;Boolean&gt; <span class="title">ifTest</span><span class="params">(<span class="meta">@RequestParam</span> Boolean flag)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ResponseEntity.ok(aService.ifTest(flag));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// service</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AService</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Integer <span class="title">add</span><span class="params">(Integer p1, Integer p2)</span></span>&#123;</span><br><span class="line">  System.out.println(p1);</span><br><span class="line">  System.out.println(p2);</span><br><span class="line">  <span class="keyword">return</span> p1 + p2;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Boolean <span class="title">ifTest</span><span class="params">(Boolean flag)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;flag is true&quot;</span>);</span><br><span class="line">  &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;flag is false&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> flag;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="jacoco-analyzer"><a href="#jacoco-analyzer" class="headerlink" title="jacoco-analyzer"></a>jacoco-analyzer</h3><p>直接使用的 jacoco 官网提供 api example：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.jacoco.org/jacoco/trunk/doc/examples/java/ExecutionDataClient.java">ExecutionDataClient.java</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jacoco.org/jacoco/trunk/doc/examples/java/ReportGenerator.java">ReportGenerator.java</a></li>
</ul>
<h2 id="jacoco-数据解析过程"><a href="#jacoco-数据解析过程" class="headerlink" title="jacoco 数据解析过程"></a>jacoco 数据解析过程</h2><p>在刚接触 jacoco 时，一直有几个疑问：exec 文件是如何被利用的？为什么必须要使用被测试服务的源码和编译出来的 class 文件？<br>本文也是主要针对这几个问题去寻找答案。</p>
<p>根据 jacoco 的需要准备材料，如下：</p>
<p><img src="/2021/06/12/jacoco-%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%90%E5%85%A8%E6%B5%81%E7%A8%8B/resources.PNG" alt="资源文件"></p>
<ul>
<li>used-classes：被测试项目的 class 文件</li>
<li>used-java：被测试项目的源码文件</li>
<li>jacoco-client.exec：拉取到 exec 文件</li>
</ul>
<p>下面就根据官网例子提供 <a target="_blank" rel="noopener" href="https://www.jacoco.org/jacoco/trunk/doc/examples/java/ReportGenerator.java">ReportGenerator.java</a> 去看看解析过程吧！</p>
<h3 id="ReportGenerator-java"><a href="#ReportGenerator-java" class="headerlink" title="ReportGenerator.java"></a>ReportGenerator.java</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReportGenerator</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String title;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> File executionDataFile;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> File classesDirectory;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> File sourceDirectory;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> File reportDirectory;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> ExecFileLoader execFileLoader;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ReportGenerator</span><span class="params">(<span class="keyword">final</span> File projectDirectory)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.title = projectDirectory.getName();</span><br><span class="line">  <span class="keyword">this</span>.executionDataFile = <span class="keyword">new</span> File(projectDirectory, <span class="string">&quot;/test-site/jacoco-client.exec&quot;</span>);</span><br><span class="line">  <span class="keyword">this</span>.classesDirectory = <span class="keyword">new</span> File(projectDirectory, <span class="string">&quot;/test-site/used-classes&quot;</span>);</span><br><span class="line">  <span class="keyword">this</span>.sourceDirectory = <span class="keyword">new</span> File(projectDirectory, <span class="string">&quot;/test-site/used-java&quot;</span>);</span><br><span class="line">  <span class="keyword">this</span>.reportDirectory = <span class="keyword">new</span> File(projectDirectory, <span class="string">&quot;/test-site/coveragereport&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">create</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="comment">// 加载 exec 文件</span></span><br><span class="line">  loadExecutionData();</span><br><span class="line">  <span class="comment">// 解析数据</span></span><br><span class="line">  <span class="keyword">final</span> IBundleCoverage bundleCoverage = analyzeStructure();</span><br><span class="line">  <span class="comment">// 创建报告</span></span><br><span class="line">  createReport(bundleCoverage);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createReport</span><span class="params">(<span class="keyword">final</span> IBundleCoverage bundleCoverage)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> HTMLFormatter htmlFormatter = <span class="keyword">new</span> HTMLFormatter();</span><br><span class="line">  <span class="keyword">final</span> IReportVisitor visitor = htmlFormatter</span><br><span class="line">    .createVisitor(<span class="keyword">new</span> FileMultiReportOutput(reportDirectory));</span><br><span class="line"></span><br><span class="line">  visitor.visitInfo(execFileLoader.getSessionInfoStore().getInfos(),</span><br><span class="line">    execFileLoader.getExecutionDataStore().getContents());</span><br><span class="line"></span><br><span class="line">  visitor.visitBundle(bundleCoverage,</span><br><span class="line">    <span class="keyword">new</span> DirectorySourceFileLocator(sourceDirectory, <span class="string">&quot;utf-8&quot;</span>, <span class="number">4</span>));</span><br><span class="line"></span><br><span class="line">  visitor.visitEnd();</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadExecutionData</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  execFileLoader = <span class="keyword">new</span> ExecFileLoader();</span><br><span class="line">  execFileLoader.load(executionDataFile);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> IBundleCoverage <span class="title">analyzeStructure</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> CoverageBuilder coverageBuilder = <span class="keyword">new</span> CoverageBuilder();</span><br><span class="line">  <span class="keyword">final</span> Analyzer analyzer = <span class="keyword">new</span> Analyzer(</span><br><span class="line">    execFileLoader.getExecutionDataStore(), coverageBuilder);</span><br><span class="line"></span><br><span class="line">  analyzer.analyzeAll(classesDirectory);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> coverageBuilder.getBundle(title);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">final</span> String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  String path = System.getProperty(<span class="string">&quot;user.dir&quot;</span>);</span><br><span class="line">  <span class="keyword">final</span> ReportGenerator generator = <span class="keyword">new</span> ReportGenerator(</span><br><span class="line">    <span class="keyword">new</span> File(path));</span><br><span class="line">  generator.create();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过主函数可以看到首先调用了 <code>generator.create()</code> 方法，该方法中将报告的生成分成了 3 步，后续我也根据这 3 步来分别分析。</p>
<h4 id="loadExecutionData：加载-exec-文件"><a href="#loadExecutionData：加载-exec-文件" class="headerlink" title="loadExecutionData：加载 exec 文件"></a>loadExecutionData：加载 exec 文件</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// private ExecFileLoader execFileLoader;</span></span><br><span class="line"><span class="comment">// this.executionDataFile = new File(projectDirectory, &quot;/test-site/jacoco-client.exec&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadExecutionData</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  execFileLoader = <span class="keyword">new</span> ExecFileLoader();</span><br><span class="line">  execFileLoader.load(executionDataFile);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很简洁的代码，首先创建一个 exec 文件加载器，然后加载它。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ExecFileLoader.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ExecFileLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  sessionInfos = <span class="keyword">new</span> SessionInfoStore();</span><br><span class="line">  executionData = <span class="keyword">new</span> ExecutionDataStore();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> ISessionInfoVisitor sessionInfoVisitor = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> IExecutionDataVisitor executionDataVisitor = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSessionInfoVisitor</span><span class="params">(<span class="keyword">final</span> ISessionInfoVisitor visitor)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.sessionInfoVisitor = visitor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setExecutionDataVisitor</span><span class="params">(<span class="keyword">final</span> IExecutionDataVisitor visitor)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.executionDataVisitor = visitor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">load</span><span class="params">(<span class="keyword">final</span> File file)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> InputStream stream = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// 1. 创建一个 InputStream，然后传给 load 方法（看来是要读文件了）</span></span><br><span class="line">  load(stream);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  stream.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">load</span><span class="params">(<span class="keyword">final</span> InputStream stream)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="comment">// 2. 创建一个 ExecutionDataReader（一个 exec 文件专用的 Reader？）</span></span><br><span class="line">  <span class="keyword">final</span> ExecutionDataReader reader = <span class="keyword">new</span> ExecutionDataReader(</span><br><span class="line">  <span class="keyword">new</span> BufferedInputStream(stream));</span><br><span class="line">  <span class="comment">// 3. 给 reader set 一个 ExecutionDataStore（看方法名字是一个 Visitor，怎么用？）</span></span><br><span class="line">  reader.setExecutionDataVisitor(executionData);</span><br><span class="line">  <span class="comment">// 4. 给 reader set 一个 SessionInfoStore（什么是 SessionInfo？）</span></span><br><span class="line">  reader.setSessionInfoVisitor(sessionInfos);</span><br><span class="line">  reader.read();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再进一层，去看看是怎么读取的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ExcutionDataReader.java</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> CompactDataInput in;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ExecutionDataReader</span><span class="params">(<span class="keyword">final</span> InputStream input)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// CompactDataInput：压缩数据输入（这里先不深入，理解为 jacoco 自己写的 exec 文件，自己就有版本解析）</span></span><br><span class="line">  <span class="keyword">this</span>.in = <span class="keyword">new</span> CompactDataInput(input);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.实际的读方法（读完后，会改变什么呢？）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  <span class="keyword">throws</span> IOException, IncompatibleExecDataVersionException </span>&#123;</span><br><span class="line">  <span class="keyword">byte</span> type;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">  <span class="keyword">int</span> i = in.read();</span><br><span class="line">  <span class="keyword">if</span> (i == -<span class="number">1</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// EOF</span></span><br><span class="line">  &#125;</span><br><span class="line">  type = (<span class="keyword">byte</span>) i;</span><br><span class="line">  <span class="keyword">if</span> (firstBlock &amp;&amp; type != ExecutionDataWriter.BLOCK_HEADER) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">&quot;Invalid execution data file.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  firstBlock = <span class="keyword">false</span>;</span><br><span class="line">  &#125; <span class="keyword">while</span> (readBlock(type));</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.读ing...</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">readBlock</span><span class="params">(<span class="keyword">final</span> <span class="keyword">byte</span> blocktype)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="comment">// 根据读到的 type 再调用不同的方法，type 分三个</span></span><br><span class="line">  <span class="comment">// ExecutionDataWriter.BLOCK_HEADER: 0x01</span></span><br><span class="line">  <span class="comment">// ExecutionDataWriter.BLOCK_SESSIONINFO: 0x10</span></span><br><span class="line">  <span class="comment">// ExecutionDataWriter.BLOCK_EXECUTIONDATA: 0x11</span></span><br><span class="line">  <span class="keyword">switch</span> (blocktype) &#123;</span><br><span class="line">  <span class="keyword">case</span> ExecutionDataWriter.BLOCK_HEADER:</span><br><span class="line">  readHeader();</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  <span class="keyword">case</span> ExecutionDataWriter.BLOCK_SESSIONINFO:</span><br><span class="line">  readSessionInfo();</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  <span class="keyword">case</span> ExecutionDataWriter.BLOCK_EXECUTIONDATA:</span><br><span class="line">  <span class="comment">// 先关注 ExecutionData</span></span><br><span class="line">  readExecutionData();</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> IOException(</span><br><span class="line">  format(<span class="string">&quot;Unknown block type %x.&quot;</span>, Byte.valueOf(blocktype)));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.读 ExecutionData</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readExecutionData</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (executionDataVisitor == <span class="keyword">null</span>) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">&quot;No execution data visitor.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">long</span> id = in.readLong();</span><br><span class="line">  <span class="keyword">final</span> String name = in.readUTF();</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">boolean</span>[] probes = in.readBooleanArray();</span><br><span class="line">  <span class="comment">// 到这里为止，把 exec 文件中的数据读出来了，详情请看下图</span></span><br><span class="line">  executionDataVisitor</span><br><span class="line">  .visitClassExecution(<span class="keyword">new</span> ExecutionData(id, name, probes));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下图中可以看到，exec 文件读取时是按类读取的，每个类有三个属性：id、name、probes（探针），其中 probes 存放的是一个 boolean 数组，再结合 jacoco 的插桩知识，可以得出 <strong>probes 是指令的覆盖情况，true 代表指令被执行，false 代表指令未执行</strong>。</p>
<img src="./exec-load.PNG" style="zoom:80%;"/>

<p>数据读取之后，将 id、name、probes 三个属性封装进 jacoco 中使用的 ExecutionData，之后又调用了 executionDataVisitor（executionDataVisitor 是 ExecutionDataStore 的对象） 的 visitClassExecution 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ExecutionDataStore.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Long, ExecutionData&gt; entries = <span class="keyword">new</span> HashMap&lt;Long, ExecutionData&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; names = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">final</span> ExecutionData data)</span> <span class="keyword">throws</span> IllegalStateException </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Long id = Long.valueOf(data.getId());</span><br><span class="line">  <span class="keyword">final</span> ExecutionData entry = entries.get(id);</span><br><span class="line">  <span class="keyword">if</span> (entry == <span class="keyword">null</span>) &#123;</span><br><span class="line">  entries.put(id, data);</span><br><span class="line">  names.add(data.getName());</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  entry.merge(data);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 将 exectionData 存储起来，ExecutionDataStore 中有两个存储的结构：</span></span><br><span class="line"><span class="comment">// 一个 HashMap：以 executionData 的 id 为 key，executionData 本身为 value 存储。</span></span><br><span class="line"><span class="comment">// 一个 Set：存储 executionData 的 name，name 就是全类名。 </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitClassExecution</span><span class="params">(<span class="keyword">final</span> ExecutionData data)</span> </span>&#123;</span><br><span class="line">  put(data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，loadExecutionData 步骤执行完毕，<strong>最后拥有了一个 executionDataStore 对象，在其之中，存放着每个类的指令覆盖情况</strong>。</p>
<img src="./executionDataStore.PNG" style="zoom:90%;"/>

<h4 id="analyzeStructure：分析结构"><a href="#analyzeStructure：分析结构" class="headerlink" title="analyzeStructure：分析结构"></a>analyzeStructure：分析结构</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  private final File classesDirectory;</span></span><br><span class="line"><span class="comment">//  this.classesDirectory = new File(projectDirectory, &quot;/test-site/used-classes&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  private final String title;</span></span><br><span class="line"><span class="comment">//  this.title = projectDirectory.getName();</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> IBundleCoverage <span class="title">analyzeStructure</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="comment">// 1.创建一个 CoverageBuilder（什么是 CoverageBuilder？）</span></span><br><span class="line">  <span class="keyword">final</span> CoverageBuilder coverageBuilder = <span class="keyword">new</span> CoverageBuilder();</span><br><span class="line">  <span class="comment">// 2.创建一个 Analyzer（什么是 Analyzer？）</span></span><br><span class="line">  <span class="keyword">final</span> Analyzer analyzer = <span class="keyword">new</span> Analyzer(</span><br><span class="line">    execFileLoader.getExecutionDataStore(), coverageBuilder);</span><br><span class="line">  <span class="comment">// 3.解析</span></span><br><span class="line">  analyzer.analyzeAll(classesDirectory);</span><br><span class="line">  <span class="comment">// 4.返回</span></span><br><span class="line">  <span class="keyword">return</span> coverageBuilder.getBundle(title);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码结构也很清晰，首先创建了一个 CoverageBuilder 对象，然后创建了一个 Analyzer 对象，然后解析，然后返回。</p>
<ul>
<li>CoverageBuilder：完全解析之后的覆盖率数据就存在这里，按类分好，之后可以通过类名等获取相应内容。</li>
<li>Analyzer：解析器…</li>
</ul>
<p>简单看下两个类的构造函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CoverageBuilder.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CoverageBuilder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.classes = <span class="keyword">new</span> HashMap&lt;String, IClassCoverage&gt;();</span><br><span class="line">  <span class="keyword">this</span>.sourcefiles = <span class="keyword">new</span> HashMap&lt;String, ISourceFileCoverage&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Analyzer.java</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ExecutionDataStore executionData;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ICoverageVisitor coverageVisitor;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> StringPool stringPool;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Analyzer</span><span class="params">(<span class="keyword">final</span> ExecutionDataStore executionData,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">final</span> ICoverageVisitor coverageVisitor)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.executionData = executionData;</span><br><span class="line">  <span class="keyword">this</span>.coverageVisitor = coverageVisitor;</span><br><span class="line">  <span class="keyword">this</span>.stringPool = <span class="keyword">new</span> StringPool();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正式进入分析数据的过程：<code>analyzer.analyzeAll(classesDirectory)</code>，传入进方法的是一个 File 对象，它本身又是一个文件夹。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Analyzer.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">analyzeAll</span><span class="params">(<span class="keyword">final</span> File file)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 1.判断是否是文件夹</span></span><br><span class="line">  <span class="keyword">if</span> (file.isDirectory()) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">final</span> File f : file.listFiles()) &#123;</span><br><span class="line">      <span class="comment">// 2.子 File 对象进行递归调用</span></span><br><span class="line">      count += analyzeAll(f);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 3.如果不是文件夹了，那就是 class 文件了，开始进入正题...</span></span><br><span class="line">    <span class="keyword">final</span> InputStream in = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 4.再调用下同类中的 analyzeAll 方法，传入的参数是一个流对象和 class 文件的绝对路径，详情请看下方的代码</span></span><br><span class="line">      count += analyzeAll(in, file.getPath());</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      in.close();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二个 analyzeAll 方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">analyzeAll</span><span class="params">(<span class="keyword">final</span> InputStream input, <span class="keyword">final</span> String location)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> ContentTypeDetector detector;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 1.创建了一个“内容类型检测器”，它能知道将要分析的文件的类型是什么，不展开讲</span></span><br><span class="line">    detector = <span class="keyword">new</span> ContentTypeDetector(input);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> IOException e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> analyzerError(location, e);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">switch</span> (detector.getType()) &#123;</span><br><span class="line">  <span class="comment">// 2.文件的类型是 class，之后的分析将会进入 analyzeClass 方法</span></span><br><span class="line">  <span class="keyword">case</span> ContentTypeDetector.CLASSFILE:</span><br><span class="line">    <span class="comment">// 3.调用同类中的 analyzeClass 方法，传入的参数有流对象和对应 class 的绝对路径，详情请继续看下方代码</span></span><br><span class="line">    analyzeClass(detector.getInputStream(), location);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">case</span> ContentTypeDetector.ZIPFILE:</span><br><span class="line">    <span class="keyword">return</span> analyzeZip(detector.getInputStream(), location);</span><br><span class="line">  <span class="keyword">case</span> ContentTypeDetector.GZFILE:</span><br><span class="line">    <span class="keyword">return</span> analyzeGzip(detector.getInputStream(), location);</span><br><span class="line">  <span class="keyword">case</span> ContentTypeDetector.PACK200FILE:</span><br><span class="line">    <span class="keyword">return</span> analyzePack200(detector.getInputStream(), location);</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// analyzeClass</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">analyzeClass</span><span class="params">(<span class="keyword">final</span> InputStream input, <span class="keyword">final</span> String location)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">byte</span>[] buffer;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 1.将流读成了字节数组</span></span><br><span class="line">    buffer = InputStreams.readFully(input);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> IOException e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> analyzerError(location, e);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 2.继续调用同类中的 analyzeClass 方法，传入的参数是字节数组和绝对路径</span></span><br><span class="line">  analyzeClass(buffer, location);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二个 analyzeClass 方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">analyzeClass</span><span class="params">(<span class="keyword">final</span> <span class="keyword">byte</span>[] buffer, <span class="keyword">final</span> String location)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 1.继续调用同类中的 analyzeClass 方法，传入的参数是字节数组</span></span><br><span class="line">    analyzeClass(buffer);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> RuntimeException cause) &#123;</span><br><span class="line">    <span class="keyword">throw</span> analyzerError(location, cause);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三个 analyzeClass 方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">analyzeClass</span><span class="params">(<span class="keyword">final</span> <span class="keyword">byte</span>[] source)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">long</span> classId = CRC64.classId(source);</span><br><span class="line">  <span class="comment">// 1.创建 ClassReader</span></span><br><span class="line">  <span class="keyword">final</span> ClassReader reader = InstrSupport.classReaderFor(source);</span><br><span class="line">  <span class="keyword">if</span> ((reader.getAccess() &amp; Opcodes.ACC_MODULE) != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ((reader.getAccess() &amp; Opcodes.ACC_SYNTHETIC) != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 2.创建访问者</span></span><br><span class="line">  <span class="keyword">final</span> ClassVisitor visitor = createAnalyzingVisitor(classId,</span><br><span class="line">      reader.getClassName());</span><br><span class="line">  <span class="comment">// 3.“开始访问”</span></span><br><span class="line">  reader.accept(visitor, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>经过上面几个 <code>analyzeAll</code> 和 <code>analyzeClass</code> 方法可以看出，jacoco 是将对各个类“各自击破”，将要去执行实际的分析过程时，类文件已经变成了字节数组。这最后一个 <code>analyzeClass</code> 方法会去执行实际的分析过程，它首先创建了一个 ClassReader（asm 包中的工具，用来读取和分析类文件），后面分析利用了<a target="_blank" rel="noopener" href="https://www.runoob.com/design-pattern/visitor-pattern.html">访问者模式</a>，jacoco 创建自己的 visitor 实现自己的逻辑。</p>
<blockquote>
<p>asm 包中的 ClassVisitor.java 和 MethodVisitor.java 有很多“钩子”可以重写，jacoco 这里主要重写了 visitEnd 方法，来实现对 Class 和 Method 的访问。</p>
</blockquote>
<p>访问流程还是通过阅读代码来跟进，在阅读源码之前有几个问题需要注意下：</p>
<ol>
<li>经过 loadExecutionData 方法，exec 文件中的指令覆盖情况已经被记录到 executionDataStore 对象中了，但是只知道指令的覆盖情况，怎么知道行的情况、分支的情况、类的情况？换句话说 jacoco 怎么将指令的覆盖情况合并为更具体的覆盖情况？</li>
</ol>
<p>下面继续阅读代码，首先回到 jacoco 创建 visitor 的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Analyzer.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> ClassVisitor <span class="title">createAnalyzingVisitor</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> classid,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">final</span> String className)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 1.classId 是通过解析字节数组获取到的，应该与 exec 文件中解析出来的 classId 相同</span></span><br><span class="line">  <span class="comment">// 从 executionData（上文提到，这是一个 ExecutionDataStore 类，按类分别存放类的 ExecutionData）</span></span><br><span class="line">  <span class="keyword">final</span> ExecutionData data = executionData.get(classid);</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">boolean</span>[] probes;</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">boolean</span> noMatch;</span><br><span class="line">  <span class="keyword">if</span> (data == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 2.如果从 executionData 对象中获取不到当前类的信息，probes（指令覆盖情况）置为 null</span></span><br><span class="line">    <span class="comment">// noMatch 是通过 executionData 中存放 className 的 set 来判断的</span></span><br><span class="line">    probes = <span class="keyword">null</span>;</span><br><span class="line">    noMatch = executionData.contains(className);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 3.如果 executionData 对象中能获取到类的信息，就正常赋值</span></span><br><span class="line">    probes = data.getProbes();</span><br><span class="line">    noMatch = <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 4.创建一个 ClassCoverageImpl 对象（ClassCoverageImpl 这是干什么的？）</span></span><br><span class="line">  <span class="keyword">final</span> ClassCoverageImpl coverage = <span class="keyword">new</span> ClassCoverageImpl(className,</span><br><span class="line">      classid, noMatch);</span><br><span class="line">  <span class="comment">// 5.创建一个 ClassAnalyzer，这就是解析器了，还将刚才创建的对象都传入了，并且重写了一个 visitEnd 方法（ClassAnalyzer 继承自 ClassProbesVisitor，ClassProbesVisitor 又继承自 ClassVisitor，所以这里可以重写 visitEnd 方法）</span></span><br><span class="line">  <span class="comment">// coverage：ClassCoverageImpl 对象，不详讲，先记得这是每个类的各维度覆盖率计数器，覆盖率数据可以通过这个类获取</span></span><br><span class="line">  <span class="comment">// probes：一个类的指令覆盖情况</span></span><br><span class="line">  <span class="comment">// stringPool：暂不清楚用处</span></span><br><span class="line">  <span class="keyword">final</span> ClassAnalyzer analyzer = <span class="keyword">new</span> ClassAnalyzer(coverage, probes,</span><br><span class="line">      stringPool) &#123;</span><br><span class="line">    <span class="comment">// （后续的逻辑会执行到这里，当访问完一个类会调用到这个方法，后文详细介绍）</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitEnd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">super</span>.visitEnd();</span><br><span class="line">      coverageVisitor.visitCoverage(coverage);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 6.创建一个 ClassProbesAdpater，该类也继承自 ClassVisitor</span></span><br><span class="line">  <span class="comment">// 这里先了解，ClassProbesAdapter 也是一个 ClassVisitor</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ClassProbesAdapter(analyzer, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到目前为止，出现的类已经比较多了，又是适配器又是访问者，jacoco 这里的水还是很深的，但是我先不关注其他的地方，还是以数据分析过程为主题去看，后面出一个 jacoco 数据分析相关类的关系图。话不多说，终于该进入到 ClassReader 了。</p>
<p>（ClassAnalyzer、ClassProbesAdpater、ClassVisitor的关系，先欠着）</p>
<p>ClassReader 中的 accept 方法接受一个 visitor（需要继承 asm 中的 ClassVisitor，ClassVisitor 是一个抽象类），visitor 可以通过重写 ClassVisitor 的方法来实现一些逻辑，ClassVisitor 中定义的方法有：</p>
<img src="./ClassVisitor.PNG" style="zoom:80%;"/>

<p>ClassVisitor 中具有两个属性，api 和 ClassVisitor 对象，并且在它的 visitXXX 方法中，都会判断 ClassVisitor 对象是不是 null，如果不是 null 则调用其相应的方法。如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ClassVisitor.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Visits the end of the class. This method, which is the last one to be called, is used to inform</span></span><br><span class="line"><span class="comment"> * the visitor that all the fields and methods of the class have been visited.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitEnd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (cv != <span class="keyword">null</span>) &#123;</span><br><span class="line">    cv.visitEnd();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -----------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// ClassProbesAdapter.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里再看 jacoco 在创建 visitor 时方法</span></span><br><span class="line"><span class="comment">// createAnalyzingVisitor 最后 return new ClassProbesAdapter(analyzer, false);</span></span><br><span class="line"><span class="comment">// ClassProbesAdapter 继承自 ClassVisitor，它的构造方法如下：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ClassProbesAdapter</span><span class="params">(<span class="keyword">final</span> ClassProbesVisitor cv,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">final</span> <span class="keyword">boolean</span> trackFrames)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">super</span>(InstrSupport.ASM_API_VERSION, cv);</span><br><span class="line">  <span class="comment">// 这里已经将 jacoco 的 ClassAnalyzer 赋值到了，所以当在 ClassReader 中调用 ClassVisitor 的 visitEnd 的方法时，会走到 ClassAnalyzer 重写的 visitEnd 方法中</span></span><br><span class="line">  <span class="keyword">this</span>.cv = cv;</span><br><span class="line">  <span class="keyword">this</span>.trackFrames = trackFrames;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ClassReader 的 accept 中会执行一些逻辑，这里也不详写，目前只知道在这个方法中可以得到当前类中有几个方法…</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ClassReader.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.Analyzer 中 reader.accept 首先调用的这个方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(<span class="keyword">final</span> ClassVisitor classVisitor, <span class="keyword">final</span> <span class="keyword">int</span> parsingOptions)</span> </span>&#123;</span><br><span class="line">  accept(classVisitor, <span class="keyword">new</span> Attribute[<span class="number">0</span>], parsingOptions);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.实际的逻辑</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(<span class="keyword">final</span> ClassVisitor classVisitor, <span class="keyword">final</span> Attribute[] attributePrototypes, <span class="keyword">final</span> <span class="keyword">int</span> parsingOptions)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...很多逻辑...跳过...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3.methodsCount 是这个类中方法的数量</span></span><br><span class="line">  <span class="keyword">int</span> methodsCount = readUnsignedShort(currentOffset);</span><br><span class="line">  currentOffset += <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">while</span> (methodsCount-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 4.处理 method</span></span><br><span class="line">    currentOffset = readMethod(classVisitor, context, currentOffset);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Visit the end of the class.</span></span><br><span class="line">  classVisitor.visitEnd();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>通过下图可以看到，在 AController 中 methodCounts 是 3（这里有一个疑问，在 AController 中明明我只写两个方法，为什么 methodCounts 会是 3 呢…这里发现每个类都有一个名字是 <code>&lt;init&gt;</code> 的方法，这里先不考虑）</p>
<img src="./methodsCount.PNG" style="zoom:80%;"/>

<p>readMethod 方法的注释是这样写的：“Reads a JVMS method_info structure and makes the given visitor visit it.”，意思就是“读取JVMS方法信息结构，并让给定的访问者访问它”，在这个方法中将会创建一个 MethodVisitor，以此来访问方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ClassReader.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">readMethod</span><span class="params">(<span class="keyword">final</span> ClassVisitor classVisitor, <span class="keyword">final</span> Context context, <span class="keyword">final</span> <span class="keyword">int</span> methodInfoOffset)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...很多逻辑...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1.传入到这个方法中的类访问者的类型是 jacoco 中的 ClassProbesAdapter</span></span><br><span class="line">  <span class="comment">// 所以执行的 visitMethod 的方法也是 ClassProbesAdapter 中重写的 visitMethod 方法</span></span><br><span class="line">  MethodVisitor methodVisitor =</span><br><span class="line">      classVisitor.visitMethod(</span><br><span class="line">          context.currentMethodAccessFlags,</span><br><span class="line">          context.currentMethodName,</span><br><span class="line">          context.currentMethodDescriptor,</span><br><span class="line">          signatureIndex == <span class="number">0</span> ? <span class="keyword">null</span> : readUtf(signatureIndex, charBuffer),</span><br><span class="line">          exceptions);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  methodVisitor.visitEnd();</span><br><span class="line">  <span class="keyword">return</span> currentOffset;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -----------------------------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ClassProbesAdapter.java</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> MethodVisitor <span class="title">visitMethod</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> access, <span class="keyword">final</span> String name,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">final</span> String desc, <span class="keyword">final</span> String signature,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">final</span> String[] exceptions)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> MethodProbesVisitor methodProbes;</span><br><span class="line">  <span class="comment">// 1.此处的 cv 是 ClassAnalyzer 对象，在 Analyzer 类中 createAnalyzingVisitor 中有记录</span></span><br><span class="line">  <span class="comment">// 这里调用的方法的逻辑在下面介绍，可先看下面 ClassAnalyzer.java 的 visitMethod 方法</span></span><br><span class="line">  <span class="keyword">final</span> MethodProbesVisitor mv = cv.visitMethod(access, name, desc,</span><br><span class="line">      signature, exceptions);</span><br><span class="line">  <span class="keyword">if</span> (mv == <span class="keyword">null</span>) &#123;</span><br><span class="line">    methodProbes = EMPTY_METHOD_PROBES_VISITOR;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    methodProbes = mv;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> MethodSanitizer(<span class="keyword">null</span>, access, name, desc, signature,</span><br><span class="line">      exceptions) &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitEnd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">super</span>.visitEnd();</span><br><span class="line">      LabelFlowAnalyzer.markLabels(<span class="keyword">this</span>);</span><br><span class="line">      <span class="keyword">final</span> MethodProbesAdapter probesAdapter = <span class="keyword">new</span> MethodProbesAdapter(</span><br><span class="line">          methodProbes, ClassProbesAdapter.<span class="keyword">this</span>);</span><br><span class="line">      <span class="keyword">if</span> (trackFrames) &#123;</span><br><span class="line">        <span class="keyword">final</span> AnalyzerAdapter analyzer = <span class="keyword">new</span> AnalyzerAdapter(</span><br><span class="line">            ClassProbesAdapter.<span class="keyword">this</span>.name, access, name, desc,</span><br><span class="line">            probesAdapter);</span><br><span class="line">        probesAdapter.setAnalyzer(analyzer);</span><br><span class="line">        methodProbes.accept(<span class="keyword">this</span>, analyzer);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        methodProbes.accept(<span class="keyword">this</span>, probesAdapter);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -----------------------------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ClassAnalyzer.java</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ClassCoverageImpl coverage;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span>[] probes;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> StringPool stringPool;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> MethodProbesVisitor <span class="title">visitMethod</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> access, <span class="keyword">final</span> String name,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">final</span> String desc, <span class="keyword">final</span> String signature,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">final</span> String[] exceptions)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 1.coverage：创建 ClassAnzlyzer 时已经将 coverage 传进来了，是一个 ClassCoverageImpl 对象</span></span><br><span class="line">  <span class="comment">// name 是类的名字</span></span><br><span class="line">  InstrSupport.assertNotInstrumented(name, coverage.getName());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.probes；在创建 ClassAnalyzer 时已经将类的 probes 传进来了</span></span><br><span class="line">  <span class="keyword">final</span> InstructionsBuilder builder = <span class="keyword">new</span> InstructionsBuilder(probes);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3.MethodAnalyzer 继承自 MethodProbesVisitor，MethodProbesVisitor 继承自 MethodVisitor</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> MethodAnalyzer(builder) &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(<span class="keyword">final</span> MethodNode methodNode,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">final</span> MethodVisitor methodVisitor)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">super</span>.accept(methodNode, methodVisitor);</span><br><span class="line">      addMethodCoverage(stringPool.get(name), stringPool.get(desc),</span><br><span class="line">          stringPool.get(signature), builder, methodNode);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>经过上述代码后可以知道 ClassReader 中 readMethod 方法会调用传入的 classVisitor 对象的 visitMethod 方法来获取一个 MethodVisitor 对象，在 readMethod 方法中获取到 MethodVisitor 对象实际是一个 MethodSanitizer 对象，它重写了 visitEnd 方法。在其重写的 visitEnd 方法中它又会执行 <code>methodProbes.accept()</code> 的方法，这个 methodProbes 对象是一个 MethodAnalyzer 的实例，所以当执行 methodProbes.accept 时，会执行 MethodAnalyzer 中重写的 accept 方法。</p>
<p>下面继续回到 readMethod 方法中，当执行到最后时，调用了 methodVisitor.visitEnd 方法，调用链如下：</p>
<p><code>MethodSanitizer.visitEnd</code> -&gt; <code>MethodAnalyzer.accept</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MethodAnalyzer.java </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当 ClassReader 中 readMethod 中的 methodVisitor.visitEnd 执行时，会执行下方的方法。</span></span><br><span class="line"><span class="comment">// 看这部分代码的逻辑，是获取当前方法的指令集合，并继续利用访问者模式，各种类型的指令集合进行操作</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(<span class="keyword">final</span> MethodNode methodNode,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">final</span> MethodVisitor methodVisitor)</span> </span>&#123;</span><br><span class="line">  methodVisitor.visitCode();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">final</span> TryCatchBlockNode n : methodNode.tryCatchBlocks) &#123;</span><br><span class="line">    n.accept(methodVisitor);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">final</span> AbstractInsnNode i : methodNode.instructions) &#123;</span><br><span class="line">    currentNode = i;</span><br><span class="line">    <span class="comment">// 1. 访问者模式，传入 methodVisitor 是 MethodProbesAdapter 对象</span></span><br><span class="line">    i.accept(methodVisitor);</span><br><span class="line">  &#125;</span><br><span class="line">  methodVisitor.visitEnd();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 MethodAnalyzer 中 accept 方法可以看到，这里将指令分别处理了。会首先调用 AbstractInsnNode 的 accept 方法，各种类型的 AbstractInsnNode 的 accept 方法又有不同，下面看下 AbstractInsnNode 的种类有哪些：</p>
<img src="./AbstractInsnNode.PNG" style="zoom:80%;"/>

<p>它们中的 accept 方法的逻辑举例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MethodInsnNode.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(<span class="keyword">final</span> MethodVisitor methodVisitor)</span> </span>&#123;</span><br><span class="line">  methodVisitor.visitMethodInsn(opcode, owner, name, desc, itf);</span><br><span class="line">  acceptAnnotations(methodVisitor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -----------------------------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// LabelNode.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(<span class="keyword">final</span> MethodVisitor methodVisitor)</span> </span>&#123;</span><br><span class="line">  methodVisitor.visitLabel(getLabel());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -----------------------------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// InsnNode.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(<span class="keyword">final</span> MethodVisitor methodVisitor)</span> </span>&#123;</span><br><span class="line">  methodVisitor.visitInsn(opcode);</span><br><span class="line">  acceptAnnotations(methodVisitor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发现各种类型的指令首先还是会调用 MethodVisitor 对象的 visitXXX 方法，那么就看下这里将会调用的实际逻辑吧</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MethodAnalyzer.java</span></span><br><span class="line"><span class="comment">// 省略了部分，在这个类中，会所有种类的指令都编写了方法，下面是部分内容</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> InstructionsBuilder builder;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitLabel</span><span class="params">(<span class="keyword">final</span> Label label)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1.可以看到，这里都会调用 builder 的方法，builder 是一个 InstructionsBuilder 对象</span></span><br><span class="line">    builder.addLabel(label);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitLineNumber</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> line, <span class="keyword">final</span> Label start)</span> </span>&#123;</span><br><span class="line">    builder.setCurrentLine(line);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitInsn</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> opcode)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 2.这里大部分指令都会调用 addInstruction 方法，这里主要关注这个方法</span></span><br><span class="line">    builder.addInstruction(currentNode);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3.同时还注意到有如下的几个方法，它们会传入指令的 id，然后调用 builder 的 addProbe 方法</span></span><br><span class="line">  <span class="comment">// 这里是不是就是我要找到指令与覆盖情况结合的逻辑呢？</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitProbe</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> probeId)</span> </span>&#123;</span><br><span class="line">    builder.addProbe(probeId, <span class="number">0</span>);</span><br><span class="line">    builder.noSuccessor();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitJumpInsnWithProbe</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> opcode, <span class="keyword">final</span> Label label,</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="keyword">final</span> <span class="keyword">int</span> probeId, <span class="keyword">final</span> IFrame frame)</span> </span>&#123;</span><br><span class="line">    builder.addInstruction(currentNode);</span><br><span class="line">    builder.addProbe(probeId, <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitInsnWithProbe</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> opcode, <span class="keyword">final</span> <span class="keyword">int</span> probeId)</span> </span>&#123;</span><br><span class="line">    builder.addInstruction(currentNode);</span><br><span class="line">    builder.addProbe(probeId, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>执行到这里可以知道，jacoco 在解析类时，会先解析类中的方法，在解析方法时又是从组成方法的指令出发。在遍历 methodNode.instructions 时发现，当在解析一个方法时，前面两个指令分别是 LabelNode 和 LineNumberNode。（LineNumberNode 可以将 InstructionBuilder 中的 currentLine 置为当前的行）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// InstructionBuilder.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span>[] probes;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> currentLine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Instruction currentInsn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;AbstractInsnNode, Instruction&gt; instructions;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;Label&gt; currentLabel;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...省略部分属性</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addInstruction</span><span class="params">(<span class="keyword">final</span> AbstractInsnNode node)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 1. 当在访问每个指令的时候，当进入一个新的行时，currentLine 会被赋值为新的行号</span></span><br><span class="line">  <span class="keyword">final</span> Instruction insn = <span class="keyword">new</span> Instruction(currentLine);</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">int</span> labelCount = currentLabel.size();</span><br><span class="line">  <span class="keyword">if</span> (labelCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = labelCount; --i &gt;= <span class="number">0</span>;) &#123;</span><br><span class="line">      LabelInfo.setInstruction(currentLabel.get(i), insn);</span><br><span class="line">    &#125;</span><br><span class="line">    currentLabel.clear();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (currentInsn != <span class="keyword">null</span>) &#123;</span><br><span class="line">    currentInsn.addBranch(insn, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  currentInsn = insn;</span><br><span class="line">  instructions.put(node, insn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.可以看到这里是从 probes 中获取指令覆盖情况，以此来判断是否执行！</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addProbe</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> probeId, <span class="keyword">final</span> <span class="keyword">int</span> branch)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">boolean</span> executed = probes != <span class="keyword">null</span> &amp;&amp; probes[probeId];</span><br><span class="line">  <span class="comment">// 3.请看下方的 Instruction 的 addBranch 方法</span></span><br><span class="line">  currentInsn.addBranch(executed, branch);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -------------------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Instruction.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Instruction 是 jacoco 中用来描述每个指令的覆盖情况的对象</span></span><br><span class="line"><span class="comment">// 在这之前，jacoco 只有一个 boolean 数组来记录指令的覆盖情况，但是还没有关联到具体的指令上</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> line;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> branches;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指令是否被执行记录于此，是一个 BitSet</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BitSet coveredBranches;</span><br><span class="line"><span class="keyword">private</span> Instruction predecessor;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> predecessorBranch;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. </span></span><br><span class="line"><span class="comment">// executed：是否被执行了</span></span><br><span class="line"><span class="comment">// branch: 是否是分支</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBranch</span><span class="params">(<span class="keyword">final</span> <span class="keyword">boolean</span> executed, <span class="keyword">final</span> <span class="keyword">int</span> branch)</span> </span>&#123;</span><br><span class="line">  branches++;</span><br><span class="line">  <span class="keyword">if</span> (executed) &#123;</span><br><span class="line">    propagateExecutedBranch(<span class="keyword">this</span>, branch);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">propagateExecutedBranch</span><span class="params">(Instruction insn, <span class="keyword">int</span> branch)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (insn != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!insn.coveredBranches.isEmpty()) &#123;</span><br><span class="line">      insn.coveredBranches.set(branch);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    insn.coveredBranches.set(branch);</span><br><span class="line">    branch = insn.predecessorBranch;</span><br><span class="line">    insn = insn.predecessor;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 这里是指令计数器，会返回指令的覆盖情况</span></span><br><span class="line"><span class="comment">// 如果 coveredBranches 是空的，就会返回一个 ICounter 对象，这个对象的 missed 是 1，covered 是 0</span></span><br><span class="line"><span class="comment">// 如果 coveredBranches 不是空的，还是返回一个 ICounter 对象，这个对象的 missed 是 0，covered 是 1</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ICounter <span class="title">getInstructionCounter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> coveredBranches.isEmpty() ? CounterImpl.COUNTER_1_0</span><br><span class="line">      : CounterImpl.COUNTER_0_1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在经过了 Method.accept 之后，类中的一个方法的每个指令就与 exec 文件中的覆盖情况结合了。然后会继续执行 ClassAnalyzer 的 addMethodCoverage 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ClassAnalyzer.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// name 是方法名字，desc 是返回值，signature 是入参和返回值</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addMethodCoverage</span><span class="params">(<span class="keyword">final</span> String name, <span class="keyword">final</span> String desc,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">final</span> String signature, <span class="keyword">final</span> InstructionsBuilder icc,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">final</span> MethodNode methodNode)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 1.icc 是 InstructionBuilder，其中记录着每个指令的覆盖情况</span></span><br><span class="line">  <span class="keyword">final</span> MethodCoverageCalculator mcc = <span class="keyword">new</span> MethodCoverageCalculator(</span><br><span class="line">      icc.getInstructions());</span><br><span class="line">  filter.filter(methodNode, <span class="keyword">this</span>, mcc);</span><br><span class="line">  <span class="keyword">final</span> MethodCoverageImpl mc = <span class="keyword">new</span> MethodCoverageImpl(name, desc,</span><br><span class="line">      signature);</span><br><span class="line">  <span class="comment">// 2.实际的计算逻辑，详情看下方截图</span></span><br><span class="line">  mcc.calculate(mc);</span><br><span class="line">  <span class="keyword">if</span> (mc.containsCode()) &#123;</span><br><span class="line">    <span class="comment">// Only consider methods that actually contain code</span></span><br><span class="line">    coverage.addMethod(mc);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下图是展示 name、desc、signature：</p>
<img src="./name-desc-signature.PNG" style="zoom:80%;"/>

<p>下图是展示 calculate 的实际逻辑，下图的 coverage 对象是 Method 级别的对象，是记录整个 Method 的覆盖情况的。再往下调用的 <code>coverage.increment</code> 方法其实做的是将指令级别的数据累加到方法上，如将方法中所有指令的 missed 相加，就是方法的 missed，将所有执行的 covered 相加，就是方法的 covered。</p>
<img src="./calculate.PNG" style="zoom:80%;"/>

<p>上图中最后调用的 <code>coverage.incrementMethodCounter()</code> 也是对方法覆盖情况的一个总结，具体逻辑如下图：</p>
<img src="./incrementMethodCounter.PNG" style="zoom:80%;"/>

<p>到这里为止，整个分析的流程就快要结束了，这里是针对方法级别的数据累加，当执行完 calculate 方法后，又会执行一个 <code>coverage.addMethod(mc)</code>，这里的 coverage 对象是类级别的对象，再往下执行就是将方法级别的数据累加到类上。</p>
<img src="./coverage-addMethod.PNG" style="zoom:80%;"/>

<p>如此如此，这般这般之后，发现 jacoco 中每个类的覆盖率数据是由指令的数据累加来的，这篇文章中最后也只得出了这个结论，在跟随源码的过程中了解到了数据走向，但是对 class 文件中的指令和 exec 文件中指令的覆盖情况结合的逻辑还不是特别清晰，这里就先粗略的理解。同时在跟进源码时发现，还需要对工具的数据结构和设计模式加强理解，比如 Instruction 处应该是使用了链表；访问者模式；适配器模式等等。之后在工作中如果有需要再来阅读代码，这篇文章的目的是先了解 jacoco 分析数据的思路。📚</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/12/jacoco-%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%90%E5%85%A8%E6%B5%81%E7%A8%8B/" data-id="ckpwhxq030001hwup9q2zf3au" data-title="jacoco: 数据解析全流程" class="article-share-link">Teilen</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/jacoco/" rel="tag">jacoco</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%A6%86%E7%9B%96%E7%8E%87/" rel="tag">覆盖率</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2021/06/12/hello-world/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Älter</strong>
      <div class="article-nav-title">Hello World</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Kategorien</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%A6%86%E7%9B%96%E7%8E%87/">服务端覆盖率</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/jacoco/" rel="tag">jacoco</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%A6%86%E7%9B%96%E7%8E%87/" rel="tag">覆盖率</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/jacoco/" style="font-size: 10px;">jacoco</a> <a href="/tags/%E8%A6%86%E7%9B%96%E7%8E%87/" style="font-size: 10px;">覆盖率</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archiv</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">June 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">letzter Beitrag</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/06/12/jacoco-%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%90%E5%85%A8%E6%B5%81%E7%A8%8B/">jacoco: 数据解析全流程</a>
          </li>
        
          <li>
            <a href="/2021/06/12/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 Liy<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>